# SQL Server 数据库比较工具 - 技术实现指南

## 项目结构初始化

### package.json 配置
```json
{
  "name": "sqlserver-database-compare",
  "version": "1.0.0",
  "description": "SQL Server 数据库比较工具",
  "main": "dist/app.js",
  "bin": {
    "sqldb-compare": "./dist/cli/index.js"
  },
  "scripts": {
    "build": "tsc",
    "dev": "ts-node src/app.ts",
    "start": "node dist/app.js",
    "test": "jest",
    "lint": "eslint src/**/*.ts",
    "clean": "rimraf dist"
  },
  "keywords": ["sqlserver", "database", "compare", "diff"],
  "author": "开发者",
  "license": "MIT"
}
```

### TypeScript 配置 (tsconfig.json)
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

## 核心类型定义

### 数据库对象类型 (src/types/database.ts)
```typescript
// 数据库连接配置
export interface DatabaseConfig {
  server: string;
  database: string;
  authentication: {
    type: 'sql' | 'windows';
    username?: string;
    password?: string;
  };
  options?: {
    encrypt?: boolean;
    trustServerCertificate?: boolean;
    connectionTimeout?: number;
    requestTimeout?: number;
  };
}

// 表结构定义
export interface TableInfo {
  schemaName: string;
  tableName: string;
  columns: ColumnInfo[];
  primaryKeys: PrimaryKeyInfo[];
  foreignKeys: ForeignKeyInfo[];
  indexes: IndexInfo[];
  constraints: ConstraintInfo[];
}

// 列信息
export interface ColumnInfo {
  columnName: string;
  position: number;
  dataType: string;
  maxLength?: number;
  precision?: number;
  scale?: number;
  isNullable: boolean;
  defaultValue?: string;
  characterSet?: string;
  collation?: string;
}

// 主键信息
export interface PrimaryKeyInfo {
  constraintName: string;
  columnName: string;
  keySequence: number;
}

// 外键信息
export interface ForeignKeyInfo {
  constraintName: string;
  columnName: string;
  referencedSchema: string;
  referencedTable: string;
  referencedColumn: string;
  updateRule: string;
  deleteRule: string;
}

// 索引信息
export interface IndexInfo {
  indexName: string;
  indexType: string;
  isUnique: boolean;
  isPrimaryKey: boolean;
  columns: IndexColumnInfo[];
}

export interface IndexColumnInfo {
  columnName: string;
  keyOrdinal: number;
  isDescending: boolean;
  isIncluded: boolean;
}

// 视图信息
export interface ViewInfo {
  schemaName: string;
  viewName: string;
  definition: string;
  checkOption?: string;
  isUpdatable: boolean;
  dependencies: DependencyInfo[];
}

// 存储过程信息
export interface ProcedureInfo {
  schemaName: string;
  procedureName: string;
  createDate: Date;
  modifyDate: Date;
  definition: string;
  parameters: ParameterInfo[];
}

// 函数信息
export interface FunctionInfo {
  schemaName: string;
  functionName: string;
  functionType: string;
  createDate: Date;
  modifyDate: Date;
  definition: string;
  parameters: ParameterInfo[];
}

// 参数信息
export interface ParameterInfo {
  parameterName: string;
  parameterId: number;
  dataType: string;
  maxLength?: number;
  precision?: number;
  scale?: number;
  isOutput?: boolean;
  hasDefault?: boolean;
  defaultValue?: string;
}

// 依赖关系
export interface DependencyInfo {
  referencedSchema: string;
  referencedObject: string;
  referencedType: string;
}

// 约束信息
export interface ConstraintInfo {
  constraintName: string;
  constraintType: 'CHECK' | 'DEFAULT' | 'UNIQUE';
  definition?: string;
  columnName?: string;
}
```

### 比较结果类型 (src/types/comparison.ts)
```typescript
// 比较结果
export interface ComparisonResult {
  source: DatabaseMetadata;
  target: DatabaseMetadata;
  differences: DatabaseDifferences;
  summary: ComparisonSummary;
  timestamp: Date;
}

// 数据库元数据
export interface DatabaseMetadata {
  databaseName: string;
  server: string;
  tables: TableInfo[];
  views: ViewInfo[];
  procedures: ProcedureInfo[];
  functions: FunctionInfo[];
  extractedAt: Date;
}

// 数据库差异
export interface DatabaseDifferences {
  tables: TableDifferences;
  views: ViewDifferences;
  procedures: ProcedureDifferences;
  functions: FunctionDifferences;
}

// 表差异
export interface TableDifferences {
  added: TableInfo[];
  removed: TableInfo[];
  modified: TableModification[];
}

// 表修改详情
export interface TableModification {
  tableName: string;
  schemaName: string;
  columnChanges: ColumnChanges;
  indexChanges: IndexChanges;
  constraintChanges: ConstraintChanges;
}

// 列变更
export interface ColumnChanges {
  added: ColumnInfo[];
  removed: ColumnInfo[];
  modified: ColumnModification[];
}

// 列修改详情
export interface ColumnModification {
  columnName: string;
  changes: ColumnPropertyChange[];
}

// 列属性变更
export interface ColumnPropertyChange {
  property: string;
  sourceValue: any;
  targetValue: any;
}

// 索引变更
export interface IndexChanges {
  added: IndexInfo[];
  removed: IndexInfo[];
  modified: IndexModification[];
}

// 索引修改详情
export interface IndexModification {
  indexName: string;
  changes: IndexPropertyChange[];
}

// 索引属性变更
export interface IndexPropertyChange {
  property: string;
  sourceValue: any;
  targetValue: any;
}

// 约束变更
export interface ConstraintChanges {
  added: ConstraintInfo[];
  removed: ConstraintInfo[];
  modified: ConstraintModification[];
}

// 约束修改详情
export interface ConstraintModification {
  constraintName: string;
  changes: ConstraintPropertyChange[];
}

// 约束属性变更
export interface ConstraintPropertyChange {
  property: string;
  sourceValue: any;
  targetValue: any;
}

// 视图差异
export interface ViewDifferences {
  added: ViewInfo[];
  removed: ViewInfo[];
  modified: ViewModification[];
}

// 视图修改详情
export interface ViewModification {
  viewName: string;
  schemaName: string;
  definitionChanged: boolean;
  sourceDefinition: string;
  targetDefinition: string;
}

// 存储过程差异
export interface ProcedureDifferences {
  added: ProcedureInfo[];
  removed: ProcedureInfo[];
  modified: ProcedureModification[];
}

// 存储过程修改详情
export interface ProcedureModification {
  procedureName: string;
  schemaName: string;
  definitionChanged: boolean;
  parametersChanged: boolean;
  sourceDefinition: string;
  targetDefinition: string;
  parameterChanges: ParameterChanges;
}

// 参数变更
export interface ParameterChanges {
  added: ParameterInfo[];
  removed: ParameterInfo[];
  modified: ParameterModification[];
}

// 参数修改详情
export interface ParameterModification {
  parameterName: string;
  changes: ParameterPropertyChange[];
}

// 参数属性变更
export interface ParameterPropertyChange {
  property: string;
  sourceValue: any;
  targetValue: any;
}

// 函数差异
export interface FunctionDifferences {
  added: FunctionInfo[];
  removed: FunctionInfo[];
  modified: FunctionModification[];
}

// 函数修改详情
export interface FunctionModification {
  functionName: string;
  schemaName: string;
  definitionChanged: boolean;
  parametersChanged: boolean;
  sourceDefinition: string;
  targetDefinition: string;
  parameterChanges: ParameterChanges;
}

// 比较摘要
export interface ComparisonSummary {
  totalTables: {
    source: number;
    target: number;
    added: number;
    removed: number;
    modified: number;
  };
  totalViews: {
    source: number;
    target: number;
    added: number;
    removed: number;
    modified: number;
  };
  totalProcedures: {
    source: number;
    target: number;
    added: number;
    removed: number;
    modified: number;
  };
  totalFunctions: {
    source: number;
    target: number;
    added: number;
    removed: number;
    modified: number;
  };
  overallStatus: 'identical' | 'different';
}
```

## 核心组件实现示例

### 数据库连接管理器 (src/connections/connection.ts)
```typescript
import * as sql from 'mssql';
import { DatabaseConfig } from '../types/database';
import { Logger } from '../utils/logger';

export class DatabaseConnection {
  private config: sql.config;
  private pool: sql.ConnectionPool | null = null;
  private logger: Logger;

  constructor(config: DatabaseConfig, logger: Logger) {
    this.logger = logger;
    this.config = this.buildConnectionConfig(config);
  }

  private buildConnectionConfig(config: DatabaseConfig): sql.config {
    const sqlConfig: sql.config = {
      server: config.server,
      database: config.database,
      options: {
        encrypt: config.options?.encrypt ?? true,
        trustServerCertificate: config.options?.trustServerCertificate ?? true,
      },
      connectionTimeout: config.options?.connectionTimeout ?? 30000,
      requestTimeout: config.options?.requestTimeout ?? 60000,
    };

    if (config.authentication.type === 'sql') {
      sqlConfig.user = config.authentication.username;
      sqlConfig.password = config.authentication.password;
    } else {
      sqlConfig.authentication = {
        type: 'ntlm',
        options: {
          domain: '',
          userName: '',
          password: '',
        },
      };
    }

    return sqlConfig;
  }

  async connect(): Promise<void> {
    try {
      this.pool = new sql.ConnectionPool(this.config);
      await this.pool.connect();
      this.logger.info(`已连接到数据库: ${this.config.server}/${this.config.database}`);
    } catch (error) {
      this.logger.error('数据库连接失败:', error);
      throw error;
    }
  }

  async executeQuery<T = any>(query: string, parameters?: any): Promise<T[]> {
    if (!this.pool) {
      throw new Error('数据库未连接');
    }

    try {
      const request = this.pool.request();
      
      // 添加参数
      if (parameters) {
        Object.keys(parameters).forEach(key => {
          request.input(key, parameters[key]);
        });
      }

      const result = await request.query(query);
      return result.recordset;
    } catch (error) {
      this.logger.error('查询执行失败:', error);
      throw error;
    }
  }

  async close(): Promise<void> {
    if (this.pool) {
      await this.pool.close();
      this.pool = null;
      this.logger.info('数据库连接已关闭');
    }
  }

  isConnected(): boolean {
    return this.pool !== null && this.pool.connected;
  }
}
```

### 表结构提取器 (src/extractors/tables.ts)
```typescript
import { DatabaseConnection } from '../connections/connection';
import { TableInfo, ColumnInfo, PrimaryKeyInfo, ForeignKeyInfo, IndexInfo } from '../types/database';
import { Logger } from '../utils/logger';

export class TableExtractor {
  private connection: DatabaseConnection;
  private logger: Logger;

  constructor(connection: DatabaseConnection, logger: Logger) {
    this.connection = connection;
    this.logger = logger;
  }

  async extractAllTables(): Promise<TableInfo[]> {
    this.logger.info('开始提取表结构信息...');
    
    const tables = await this.getTableList();
    const tableInfos: TableInfo[] = [];

    for (const table of tables) {
      try {
        const tableInfo = await this.extractTableInfo(table.schemaName, table.tableName);
        tableInfos.push(tableInfo);
        this.logger.debug(`已提取表: ${table.schemaName}.${table.tableName}`);
      } catch (error) {
        this.logger.error(`提取表 ${table.schemaName}.${table.tableName} 失败:`, error);
      }
    }

    this.logger.info(`表结构提取完成，共 ${tableInfos.length} 个表`);
    return tableInfos;
  }

  private async getTableList(): Promise<{ schemaName: string; tableName: string }[]> {
    const query = `
      SELECT 
        t.TABLE_SCHEMA as schemaName,
        t.TABLE_NAME as tableName
      FROM INFORMATION_SCHEMA.TABLES t
      WHERE t.TABLE_TYPE = 'BASE TABLE'
      ORDER BY t.TABLE_SCHEMA, t.TABLE_NAME
    `;

    return await this.connection.executeQuery(query);
  }

  private async extractTableInfo(schemaName: string, tableName: string): Promise<TableInfo> {
    const [columns, primaryKeys, foreignKeys, indexes, constraints] = await Promise.all([
      this.getColumns(schemaName, tableName),
      this.getPrimaryKeys(schemaName, tableName),
      this.getForeignKeys(schemaName, tableName),
      this.getIndexes(schemaName, tableName),
      this.getConstraints(schemaName, tableName),
    ]);

    return {
      schemaName,
      tableName,
      columns,
      primaryKeys,
      foreignKeys,
      indexes,
      constraints,
    };
  }

  private async getColumns(schemaName: string, tableName: string): Promise<ColumnInfo[]> {
    const query = `
      SELECT 
        c.COLUMN_NAME as columnName,
        c.ORDINAL_POSITION as position,
        c.COLUMN_DEFAULT as defaultValue,
        c.IS_NULLABLE as isNullable,
        c.DATA_TYPE as dataType,
        c.CHARACTER_MAXIMUM_LENGTH as maxLength,
        c.NUMERIC_PRECISION as precision,
        c.NUMERIC_SCALE as scale,
        c.CHARACTER_SET_NAME as characterSet,
        c.COLLATION_NAME as collation
      FROM INFORMATION_SCHEMA.COLUMNS c
      WHERE c.TABLE_NAME = @tableName 
        AND c.TABLE_SCHEMA = @schemaName
      ORDER BY c.ORDINAL_POSITION
    `;

    const results = await this.connection.executeQuery(query, { schemaName, tableName });
    
    return results.map(row => ({
      columnName: row.columnName,
      position: row.position,
      dataType: row.dataType,
      maxLength: row.maxLength,
      precision: row.precision,
      scale: row.scale,
      isNullable: row.isNullable === 'YES',
      defaultValue: row.defaultValue,
      characterSet: row.characterSet,
      collation: row.collation,
    }));
  }

  private async getPrimaryKeys(schemaName: string, tableName: string): Promise<PrimaryKeyInfo[]> {
    const query = `
      SELECT 
        tc.CONSTRAINT_NAME as constraintName,
        kcu.COLUMN_NAME as columnName,
        kcu.ORDINAL_POSITION as keySequence
      FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
      JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu 
        ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
        AND tc.TABLE_SCHEMA = kcu.TABLE_SCHEMA
        AND tc.TABLE_NAME = kcu.TABLE_NAME
      WHERE tc.CONSTRAINT_TYPE = 'PRIMARY KEY'
        AND tc.TABLE_SCHEMA = @schemaName
        AND tc.TABLE_NAME = @tableName
      ORDER BY kcu.ORDINAL_POSITION
    `;

    return await this.connection.executeQuery(query, { schemaName, tableName });
  }

  private async getForeignKeys(schemaName: string, tableName: string): Promise<ForeignKeyInfo[]> {
    const query = `
      SELECT 
        rc.CONSTRAINT_NAME as constraintName,
        kcu1.COLUMN_NAME as columnName,
        kcu2.TABLE_SCHEMA as referencedSchema,
        kcu2.TABLE_NAME as referencedTable,
        kcu2.COLUMN_NAME as referencedColumn,
        rc.UPDATE_RULE as updateRule,
        rc.DELETE_RULE as deleteRule
      FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc
      JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu1 
        ON rc.CONSTRAINT_NAME = kcu1.CONSTRAINT_NAME
        AND rc.CONSTRAINT_SCHEMA = kcu1.CONSTRAINT_SCHEMA
      JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu2 
        ON rc.UNIQUE_CONSTRAINT_NAME = kcu2.CONSTRAINT_NAME
        AND rc.UNIQUE_CONSTRAINT_SCHEMA = kcu2.CONSTRAINT_SCHEMA
        AND kcu1.ORDINAL_POSITION = kcu2.ORDINAL_POSITION
      WHERE kcu1.TABLE_SCHEMA = @schemaName
        AND kcu1.TABLE_NAME = @tableName
      ORDER BY rc.CONSTRAINT_NAME, kcu1.ORDINAL_POSITION
    `;

    return await this.connection.executeQuery(query, { schemaName, tableName });
  }

  private async getIndexes(schemaName: string, tableName: string): Promise<IndexInfo[]> {
    const query = `
      SELECT 
        i.name as indexName,
        i.type_desc as indexType,
        i.is_unique as isUnique,
        i.is_primary_key as isPrimaryKey,
        ic.key_ordinal as keyOrdinal,
        c.name as columnName,
        ic.is_descending_key as isDescending,
        ic.is_included_column as isIncluded
      FROM sys.indexes i
      JOIN sys.tables t ON i.object_id = t.object_id
      JOIN sys.schemas s ON t.schema_id = s.schema_id
      JOIN sys.index_columns ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id
      JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id
      WHERE i.type > 0
        AND s.name = @schemaName
        AND t.name = @tableName
      ORDER BY i.name, ic.key_ordinal
    `;

    const results = await this.connection.executeQuery(query, { schemaName, tableName });
    
    // 按索引名称分组
    const indexMap = new Map<string, IndexInfo>();
    
    results.forEach(row => {
      const indexName = row.indexName;
      
      if (!indexMap.has(indexName)) {
        indexMap.set(indexName, {
          indexName,
          indexType: row.indexType,
          isUnique: row.isUnique,
          isPrimaryKey: row.isPrimaryKey,
          columns: [],
        });
      }
      
      const index = indexMap.get(indexName)!;
      index.columns.push({
        columnName: row.columnName,
        keyOrdinal: row.keyOrdinal,
        isDescending: row.isDescending,
        isIncluded: row.isIncluded,
      });
    });

    return Array.from(indexMap.values());
  }

  private async getConstraints(schemaName: string, tableName: string): Promise<any[]> {
    // 实现约束提取逻辑
    return [];
  }
}
```

## 使用示例

### CLI 入口点 (src/cli/index.ts)
```typescript
#!/usr/bin/env node

import { Command } from 'commander';
import { CompareCommand } from './commands/compare';
import { ConfigCommand } from './commands/config';
import { Logger } from '../utils/logger';

const program = new Command();
const logger = new Logger();

program
  .name('sqldb-compare')
  .description('SQL Server 数据库比较工具')
  .version('1.0.0');

// 比较命令
program
  .command('compare')
  .description('比较两个数据库')
  .option('-s, --source <source>', '源数据库连接字符串')
  .option('-t, --target <target>', '目标数据库连接字符串')
  .option('-c, --config <config>', '配置文件路径')
  .option('-o, --output <output>', '输出目录', './reports')
  .option('-f, --format <format>', '报告格式 (html,excel,json)', 'html')
  .action(async (options) => {
    const compareCmd = new CompareCommand(logger);
    await compareCmd.execute(options);
  });

// 配置命令
program
  .command('init')
  .description('初始化配置文件')
  .option('-o, --output <output>', '配置文件输出路径', './config.json')
  .action(async (options) => {
    const configCmd = new ConfigCommand(logger);
    await configCmd.init(options);
  });

program.parse();
```

这个技术实现指南提供了：

1. **完整的项目配置**：package.json 和 tsconfig.json
2. **详细的类型定义**：数据库对象和比较结果的类型
3. **核心组件实现**：连接管理器和数据提取器示例
4. **CLI接口设计**：命令行工具的入口点

接下来可以根据这个指南开始实际的代码实现。